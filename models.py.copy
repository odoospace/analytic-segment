# -*- coding: utf-8 -*-
# More simple segment model to use in odoo analytic and no analytic objects

from openerp import models, fields, api

PATTERN = ['%i', '%02i', '%06i']
MAX_LEVEL = len(PATTERN)

class analytic_segment(models.Model):
    _name = 'analytic_segment.segment'
    _description = 'Segments for analytic porpouse'

    @api.multi
    def name_get(self):
        res = []
        for obj in self:
            name = '%s [%s]' % (obj.name, obj.type_id.name)
            res.append((obj.id, name))
        return res

    @api.onchange('type_id')
    def _set_level(self):
        # only select stuff from your upper level
        self.parent_id = ''
        res = {}
        res['domain'] = {
            'parent_id': [('level', '=', self.type_id.level_parent)]
        }
        return res

    @api.depends('parent_id')
    @api.one
    def _get_level(self):
        """recursively get depth level in tree"""
        level = 1
        parent = self.parent_id
        while parent:
            level += 1
            parent = parent.parent_id
        self.level = level


    @api.depends('parent_id', 'code', 'type_id')
    @api.one
    def _get_fullcode(self):
        """recursively get depth level in tree"""
        for obj in self:
            # segment is empty for virtual ones
            if obj.virtual or not obj.type_id:
                obj.segment = ''
                continue
            else:
                if obj.parent_id:
                    fullcode = obj._get_fullcode(obj.parent_id, [obj.code])
                else:
                    fullcode = [obj.code]
            #fullcode = [PATTERN[k] % int(v) for k,v in enumerate(sorted(fullcode) + (['0']*(MAX_LEVEL-1))[len(fullcode):])]

            # three segments...
            newfullcode = [PATTERN[0] % int(obj.type_id.code)]
            if obj.type_id.code in ['1', '2']:
                newfullcode.append(PATTERN[1] % int(obj.code))
                newfullcode.append(PATTERN[2] % 0)
            elif obj.type_id.level_parent == 2:
                newfullcode.append(PATTERN[1] % int(obj.parent_id.code))
                newfullcode.append(PATTERN[2] % int(obj.code))
            else:
                newfullcode.append(PATTERN[1] % int(obj.parent_id.parent_id.code))
                newfullcode.append(PATTERN[2] % int(obj.code))


            obj.segment = '.'.join(newfullcode)

    # fields
    code = fields.Char(required=True)
    name = fields.Char(required=True)
    type_id = fields.Many2one('analytic_segment.type', required=True) # first segment
    segment = fields.Char(compute="_get_fullcode", store=True, readonly=True)
    level = fields.Integer(compute="_get_level", store=True, readonly=True)
    level_parent = fields.Integer(related="type_id.level_parent", readonly=True)
    virtual = fields.Boolean(default=False) # we can't use virtual segments
    blocked = fields.Boolean(default=False)
    parent_id = fields.Many2one('analytic_segment.segment')
    child_ids = fields.One2many('analytic_segment.segment', 'parent_id')


class analytic_segment(models.Model):
    _name = 'analytic_segment.type'
    _description = 'Type of segments for analytic porpouse'

    code = fields.Char(required=True)
    name = fields.Char(required=True)
    level_parent = fields.Integer(required=True)
    segment_ids = fields.One2many('analytic_segment.segment', 'type_id')
